## Service Interface와 Service Implements

- 많은 프로젝트에서 사용하는 구조이지만 대부분 1:1 관계를 맺고 있는 점이 이상해서 
이걸 왜 쓰는지 어떻게 써야 하는지에 대해서 공부해봤다.

## Interface

- 객체의 사용 방법을 정의한 타입으로 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다. → 대입하는 객체에 따른 다른 결과 값이 나올 수 있다.
- 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위해 사용한다.
- Loose Coupling
- JAVA8이전에는 추상 메소드와 상수만 선언할 수 있어 강제성이 더 컸다.
- 디폴트 메소드와 정적 메소드를 추가해서 유연성을 추가했다.
    - 용어
        
        상수 : 인터페이스에서 값을 정해줄테니 함부로 바꾸지 말고 제공해주는 값만 참조해라 (절대적)
        
        추상메소드 : 가이드만 줄테니 추상메소드를 오버라이딩해서 재구현해라. (강제적)
        
        디폴트메소드 : 인터페이스에서 기본적으로 제공해주지만, 맘에 안들면 각자 구현해서 써라. (선택적)
        
        정적메소드 : 인터페이스에서 제공해주는 것으로 무조건 사용 (절대적)
        

## OCP

- 객체 지향의 다섯 가지 원칙 중 하나인 개방, 폐쇄 원칙으로 
'소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.’
- 위와 같은 설계가 이를 가장 잘 실현해 주는 설계 방식

## 예시

- 금융결제원과 은행들
→ 가이드를 따르지 않으면 금융결제원의 서비스를 이용하지 못함

## 지속적으로 사용해야하는 이유

- 지금 만들어서 사용중인 인터페이스와 구현체 클래스가 1:1 관계를 맺고 있을지 모르지만 
서비스가 커지고 변화함에 따라서 얼마든지 구현체 클래스는 확장될 가능성을 가지고 있다.
그렇기 때문에 이러한 구조를 통해 미래의 변화에 유연하게 대처할 수 있도록 대비해야 한다.
- 프로젝트를 시작할 때 설계자가 프로젝트의 큰 뼈대를 구성함으로써 협업에 이점이 될 수 있다.

## 현실적

- 코드 구조가 복잡해지고, 복잡해진 구조 만큼 코드를 분석하고 확인하는 과정에서 인터페이스를 거쳐 구현체들을 확인해야 하는 번거로움이 생기는 단점이 있다.
- “You aren't going to need it” (YAGNI) 원칙
→ ‘필요할지도 몰라’ 라는 이유로 복잡성을 높일 이유는 없는데 , 일반적으로 필요하지 않기 때문이다.